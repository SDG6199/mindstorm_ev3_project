#pragma config(Sensor, S1,     gyro,           sensorEV3_Gyro)
#pragma config(Sensor, S2,     right_color,    sensorEV3_Color)
#pragma config(Sensor, S3,     ball_color,     sensorColorNxtFULL)
#pragma config(Sensor, S4,     left_color,     sensorEV3_Color)
#pragma config(Motor,  motorA,          lm,            tmotorEV3_Large, PIDControl, reversed, encoder)
#pragma config(Motor,  motorC,          door,          tmotorEV3_Large, PIDControl, reversed, encoder)
#pragma config(Motor,  motorD,          rm,            tmotorEV3_Large, PIDControl, reversed, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// RED team start!
// RED team start!
// RED team start!
// RED team start!
// RED team start!

int x, y=0;
int threshold=30;        
int look_threshold=30;   
int count_threshold=15;  
int blue_start_threshold=25; //  @@

int on_positive_x, on_positive_y, on_negative_x, on_negative_y=0;
int count=0, count_prev=-1;
float turn_speed=15;
int checked_blue,checked_red=0;
int look_angle=30;
int event, count3, count4=0;  // use in alingnment.
int ignore_letsgo = 0;   // if 1, ignore letsgo.
int kept_x = 0;     // temporary restore coordinate.
int kept_y = 0;
int keep_count=0;  // keeping ball left/right.
int same_dest=0;
int ball_x_6,ball_x_1,ball_x_7,ball_x_1_y_8,ball_y_1=0;
int turn_linetracing_flag=0;
int have_ball=0;
int rand_num=0;

void front_linetracing();
void align_linetracing();
void backward_advance();
void look_positive_y();
void look_positive_x();
void look_negative_x();
void look_negative_y();
void letsgo(int a, int b);
void avoid_ball(int c, int d);
void short_short_advance();
void short_advance();
void goal();
void keeping_ball();

task count_xy()
{
   while(1)
   {
      if((SensorValue[left_color]<count_threshold))
      {
         if(count==count_prev)
         {
               count++;
               if(on_positive_y==1)   //+yi?i    i
               {
                  y++;
               }
               if(on_negative_x==1)  //-xi?i    i
               {
                  x--;
               }
               if(on_positive_x==1)  //+xi?i    i
               {
                  x++;

               }
               if(on_negative_y==1)  //-yi?i    i
               {
                  y--;
               }
               setLEDColor(ledRedFlash);
               PlaySound(soundBeepBeep);
         }
      }
      else
      {
         count_prev=count;
         setLEDColor(ledOff);
      }
      sleep(1);
   }
}
task alignment()
{
   event=1;
   delay(2500);   //align time.
   resetGyro(gyro);
   event=0;
   stopTask(alignment);
}
task keep_alignment()
{
   event=1;
   delay(4000);   //ball_align time.  //@@
   event=0;
   stopTask(keep_alignment);
}
task turn_linetracing_time()
{
   turn_linetracing_flag=1;
   delay(2000);
   turn_linetracing_flag=0;
   stopTask(turn_linetracing_time);
}
task display()
{
   while(1)
   {
    displayBigTextLine(2,"x= %d",x);
    displayBigTextLine(4,"y= %d",y);
    displayBigTextLine(6,"gyro=%d",getGyroDegrees(gyro));
    sleep(1);
   }
}
task check_ball()
{
   while(1)
   {
      if((SensorValue[ball_color]==10)||(SensorValue[ball_color]==9))  //RED:10 or 9, BLUE: 2
      {
         checked_red=1;
         break;
      }
      if(SensorValue[ball_color]==2)  //RED:10 or 9, BLUE: 2
      {
          if(have_ball==1)
         {
            checked_red=1;
            break;
         }
         checked_blue=1;
         break;
      }
   }

}
task determine_direction()
{
   while(1)
   {
      if(((0-30 <= SensorValue[gyro]%360) && (SensorValue[gyro]%360<= 0+30))\
      ||((-359<= SensorValue[gyro]%360) && (SensorValue[gyro]%360<= -330))\
      ||((330<= SensorValue[gyro]%360) && (SensorValue[gyro]%360<= 359)))
      {
         on_positive_x=0;
         on_positive_y=1;
         on_negative_x=0;
         on_negative_y=0;
      }
      if(((90-30 <= SensorValue[gyro]%360) && (SensorValue[gyro]%360<= 90+30))\
      || ((-270-30 <= SensorValue[gyro]%360) && (SensorValue[gyro]%360<= -270+30)))
      {
         on_positive_x=0;
         on_positive_y=0;
         on_negative_x=1;
         on_negative_y=0;
      }

      if(((-90-30 <= SensorValue[gyro]%360) && (SensorValue[gyro]%360<= -90+30)) \
      || ((270-30 <= SensorValue[gyro]%360) && (SensorValue[gyro]%360<= 270+30)))
      {
         on_positive_x=1;
         on_positive_y=0;
         on_negative_x=0;
         on_negative_y=0;
      }

      if(((180-30<= SensorValue[gyro]%360) && (SensorValue[gyro]%360<= 180+30))\
      || ((-180-30<= SensorValue[gyro]%360) && (SensorValue[gyro]%360<= -180+30)))
      {
         on_positive_x=0;
         on_positive_y=0;
         on_negative_x=0;
         on_negative_y=1;
      }
   }
   sleep(1);
}
//------void-----------------------------------------------------------------------------------------------------------------------------------------
//------void-----------------------------------------------------------------------------------------------------------------------------------------
//------void-----------------------------------------------------------------------------------------------------------------------------------------
void goal()
{
   stoptask(count_xy);
   while((!(-140<SensorValue[gyro]%360 && SensorValue[gyro]%360<-120))&& \
      (!(220<SensorValue[gyro]%360 && SensorValue[gyro]%360<240)))
   {
      setMotorSpeed(lm,15);
      setMotorSpeed(rm,-15);
   }
   setMotorSpeed(lm,0);
   setMotorSpeed(rm,0);
   moveMotorTarget(door,150, 30);
   waitUntilMotorStop(door);
   sleep(3000);
   while((!(-15<SensorValue[gyro]%360 && SensorValue[gyro]%360<-1))&& \
      (!(345<SensorValue[gyro]%360 && SensorValue[gyro]%360<359)))
   {
      setMotorSpeed(lm,-15);
      setMotorSpeed(rm,15);
   }
   setMotorSpeed(lm,0);
   setMotorSpeed(rm,0);

   moveMotorTarget(door,150, -30);
   waitUntilMotorStop(door);
   starttask(count_xy);
}
void front_linetracing()
{
   same_dest=0;
   if(SensorValue[right_color]>threshold)
   {
      if(turn_linetracing_flag==1)
      {
         while(SensorValue[right_color]>threshold)
         {
            setMotorSpeed(lm,20*1/4); //@
            setMotorSpeed(rm,60*1/4);
         }
      }
      else if(event==1)
      {
         if(count3==0)
         {
            while(SensorValue[right_color]>threshold)
            {
               setMotorSpeed(lm,15*0.5);
               setMotorSpeed(rm,30*0.5);
            }
            count3++;
         }
         else
         {
            setMotorSpeed(lm,2);
            setMotorSpeed(rm,3);
         }
      }
      else
      {
         setMotorSpeed(lm,30*4/5);
         setMotorSpeed(rm,45*4/5);
         count3=0;
      }
   }
   else
   {
      if(turn_linetracing_flag==1)
      {
         while(SensorValue[right_color]<threshold)
         {
            setMotorSpeed(lm,40*1/5);
            setMotorSpeed(rm,10*1/5);
         }
      }
      else if(event==1)
      {
         if(count4==0)
         {
            while(SensorValue[right_color]<threshold)
            {
               setMotorSpeed(lm,30*0.5);
               setMotorSpeed(rm,15*0.5);
            }
            count4++;
         }
         else
         {
            setMotorSpeed(lm,3);
            setMotorSpeed(rm,2);
         }
      }
      else
      {
         setMotorSpeed(lm,45*4/5);
         setMotorSpeed(rm,30*4/5);
         count4=0;
      }
   }
}
void align_linetracing()
{
   while(event==1)
   {
      same_dest=0;
      if(SensorValue[right_color]>threshold)
      {
         if(count3==0)
         {
            while(SensorValue[right_color]>threshold)
            {
               setMotorSpeed(lm,25*0.3);
               setMotorSpeed(rm,30*0.3);
            }
            count3++;
         }
         else
         {
            setMotorSpeed(lm,2); //@
            setMotorSpeed(rm,3);
         }
      }
      else
      {
         if(count4==0)
         {
            while(SensorValue[right_color]<threshold)
            {
               setMotorSpeed(lm,30*0.3);
               setMotorSpeed(rm,25*0.3);
            }
            count4++;
         }
         else
         {
            setMotorSpeed(lm,3);
            setMotorSpeed(rm,2);
         }
      }
   }
   count3=0;
   count4=0;
}
void backward_advance()
{
    setMotorSpeed(lm,-10);
    setMotorSpeed(rm,-10);
}
void look_positive_y()
{
   stopTask(check_ball);
   stoptask(count_xy);
   while(1)
   {
      if(on_positive_y==1)
      {
         break;
      }
      else if(on_positive_x==1)
      {
         while((!(-look_angle<SensorValue[gyro]%360 && SensorValue[gyro]%360<0))&& \
         (!(-look_angle+360<SensorValue[gyro]%360 && SensorValue[gyro]%360<360))) //-90i??i?? -10e  ?i ii    i    i
         {
            setMotorSpeed(lm,-turn_speed);
            setMotorSpeed(rm,turn_speed);
         }

         while(SensorValue(right_color)>look_threshold)
         {
            setMotorSpeed(lm,-turn_speed/2);
            setMotorSpeed(rm,turn_speed/2);
         }
         break;
      }
      else if(on_negative_x==1)
      {
         while((!(0<SensorValue[gyro]%360 && SensorValue[gyro]%360<look_angle))&& \
         (!(-360<SensorValue[gyro]%360 && SensorValue[gyro]%360<look_angle-360)))
         {
            setMotorSpeed(lm,turn_speed);
            setMotorSpeed(rm,-turn_speed);
         }
         while(SensorValue(right_color)>look_threshold)
         {
            setMotorSpeed(lm,turn_speed/2);
            setMotorSpeed(rm,-turn_speed/2);
         }
         break;
      }
      else if(on_negative_y==1)
      {
         while((!(-look_angle<SensorValue[gyro]%360 && SensorValue[gyro]%360<0))&& \
         (!(-look_angle+360<SensorValue[gyro]%360 && SensorValue[gyro]%360<360)))
         {
            setMotorSpeed(lm,-turn_speed);
            setMotorSpeed(rm,turn_speed);
         }
         while(SensorValue(right_color)>look_threshold)
         {
            setMotorSpeed(lm,-turn_speed/2);
            setMotorSpeed(rm,turn_speed/2);
         }
         break;
      }
   }
   setMotorSpeed(lm,0);
   setMotorSpeed(rm,0);
   delay(250);
   starttask(count_xy);
   startTask(check_ball);
   Starttask(turn_linetracing_time);
}
void look_positive_x()
{
   stopTask(check_ball);
   stoptask(count_xy);
   while(1)
   {
      if(on_positive_x==1)
      {
         break;
      }
      else if(on_positive_y==1)
      {
         while((!(-90<SensorValue[gyro]%360 && SensorValue[gyro]%360<-90+look_angle))&& \
         (!(270<SensorValue[gyro]%360 && SensorValue[gyro]%360<270+look_angle)))
         {
            setMotorSpeed(lm,turn_speed);
            setMotorSpeed(rm,-turn_speed);
         }
         while(SensorValue(right_color)>look_threshold)
         {
            setMotorSpeed(lm,turn_speed/1.5);
            setMotorSpeed(rm,-turn_speed/1.5);
         }
         break;
      }
      else if(on_negative_x==1)
      {
         while((!(-90<SensorValue[gyro]%360 && SensorValue[gyro]%360<-90+look_angle))&& \
         (!(270<SensorValue[gyro]%360 && SensorValue[gyro]%360<270+look_angle)))
         {
            setMotorSpeed(lm,turn_speed);
            setMotorSpeed(rm,-turn_speed);
         }
         while(SensorValue(right_color)>look_threshold)
         {
            setMotorSpeed(lm,turn_speed/1.5);
            setMotorSpeed(rm,-turn_speed/1.5);
         }
         break;
      }
      else if(on_negative_y==1)
      {
         while((!(-90-look_angle<SensorValue[gyro]%360 && SensorValue[gyro]%360<-90))&& \
         (!(270-look_angle<SensorValue[gyro]%360 && SensorValue[gyro]%360<270)))
         {
            setMotorSpeed(lm,-turn_speed);
            setMotorSpeed(rm,turn_speed);
         }
         while(SensorValue(right_color)>look_threshold)
         {
            setMotorSpeed(lm,-turn_speed/1.5);
            setMotorSpeed(rm,turn_speed/1.5);
         }
         break;
      }
   }
   setMotorSpeed(lm,0);
   setMotorSpeed(rm,0);
   delay(250);
   starttask(count_xy);
   startTask(check_ball);
   Starttask(turn_linetracing_time);
}
void look_negative_y()
{
   stopTask(check_ball);
   stoptask(count_xy);
   while(1)
   {
      if(on_negative_y==1)
      {
         break;
      }
      else if(on_positive_y==1)
      {
         while((!(180<SensorValue[gyro]%360 && SensorValue[gyro]%360<180+look_angle))&& \
         (!(-180<SensorValue[gyro]%360 && SensorValue[gyro]%360<-180+look_angle)))
         {
            setMotorSpeed(lm,turn_speed);
            setMotorSpeed(rm,-turn_speed);
         }
         while(SensorValue(right_color)>look_threshold)
         {
            setMotorSpeed(lm,turn_speed/1.5);
            setMotorSpeed(rm,-turn_speed/1.5);
         }
         break;
      }
      else if(on_positive_x==1)
      {
         while((!(180<SensorValue[gyro]%360 && SensorValue[gyro]%360<180+look_angle))&& \
         (!(-180<SensorValue[gyro]%360 && SensorValue[gyro]%360<-180+look_angle)))
         {
            setMotorSpeed(lm,turn_speed);
            setMotorSpeed(rm,-turn_speed);
         }
         while(SensorValue(right_color)>look_threshold)
         {
            setMotorSpeed(lm,turn_speed/1.5);
            setMotorSpeed(rm,-turn_speed/1.5);
         }
         break;
      }
      else if(on_negative_x==1)
      {
         while((!(180-look_angle<SensorValue[gyro]%360 && SensorValue[gyro]%360<180))&& \
         (!(-180-look_angle<SensorValue[gyro]%360 && SensorValue[gyro]%360<-180)))
         {
            setMotorSpeed(lm,-turn_speed);
            setMotorSpeed(rm,turn_speed);
         }
         while(SensorValue(right_color)>look_threshold)
         {
            setMotorSpeed(lm,-turn_speed/1.5);
            setMotorSpeed(rm,turn_speed/1.5);
         }
         break;
      }
   }
   setMotorSpeed(lm,0);
   setMotorSpeed(rm,0);
   delay(250);
   starttask(count_xy);
   startTask(check_ball);
   Starttask(turn_linetracing_time);
}
void look_negative_x()
{
   stopTask(check_ball);
   stoptask(count_xy);
   while(1)
   {
      if(on_negative_x==1)
      {
         break;
      }
      else if(on_positive_y==1)
      {
         while((!(90-look_angle<SensorValue[gyro]%360 && SensorValue[gyro]%360<90))&& \
         (!(-270-look_angle<SensorValue[gyro]%360 && SensorValue[gyro]%360<-270)))
         {
            setMotorSpeed(lm,-turn_speed);
            setMotorSpeed(rm,turn_speed);
         }
         while(SensorValue(right_color)>look_threshold)
         {
            setMotorSpeed(lm,-turn_speed/1.5);
            setMotorSpeed(rm,turn_speed/1.5);
         }
         break;
      }
      else if(on_positive_x==1)
      {
         while((!(90-look_angle<SensorValue[gyro]%360 && SensorValue[gyro]%360<90))&& \
         (!(-270-look_angle<SensorValue[gyro]%360 && SensorValue[gyro]%360<-270)))
         {
            setMotorSpeed(lm,-turn_speed);
            setMotorSpeed(rm,turn_speed);
         }
         while(SensorValue(right_color)>look_threshold)
         {
            setMotorSpeed(lm,-turn_speed/1.5);
            setMotorSpeed(rm,turn_speed/1.5);
         }
         break;
      }
      else if(on_negative_y==1)
      {
         while((!(90<SensorValue[gyro]%360 && SensorValue[gyro]%360<90+look_angle))&& \
         (!(-270<SensorValue[gyro]%360 && SensorValue[gyro]%360<-270+look_angle)))
         {
            setMotorSpeed(lm,turn_speed);
            setMotorSpeed(rm,-turn_speed);
         }
         while(SensorValue(right_color)>look_threshold)
         {
            setMotorSpeed(lm,turn_speed/1.5);
            setMotorSpeed(rm,-turn_speed/1.5);
         }
         break;
      }
   }
   setMotorSpeed(lm,0);
   setMotorSpeed(rm,0);
   delay(250);
   starttask(count_xy);
   startTask(check_ball);
   Starttask(turn_linetracing_time);
}
void short_advance()
{
   moveMotorTarget(lm, 157, 20);
   moveMotorTarget(rm, 157, 20);   //backward
   waitUntilMotorStop(lm);
   waitUntilMotorStop(rm);
   return ;
}
void short_short_advance()
{
   moveMotorTarget(lm, 130, 20);
   moveMotorTarget(rm, 130, 20);   //backward
   waitUntilMotorStop(lm);
   waitUntilMotorStop(rm);
   return ;
}
void keeping_ball()
{
   keep_count++;
   moveMotorTarget(lm, 60, -10);
   moveMotorTarget(rm, 60, -10);   //backward
   waitUntilMotorStop(lm);
   waitUntilMotorStop(rm);
   moveMotorTarget(door,100, 50);  //door open
   waitUntilMotorStop(door);

   startTask(keep_alignment);  // @
   
   align_linetracing();
  
   if(keep_count%2==1)
   {
      moveMotorTarget(lm, 35, 10);
      moveMotorTarget(rm, 35, -10);  //clockwise_turn
      waitUntilMotorStop(lm);
      waitUntilMotorStop(rm);
   }
   else
   {
      moveMotorTarget(lm, 35, -10);
      moveMotorTarget(rm, 35, 10);  //counterclockwise_turn
      waitUntilMotorStop(lm);
      waitUntilMotorStop(rm);
   }
   moveMotorTarget(door,100, -40);  //door close
   waitUntilMotorStop(door);
   if(keep_count%2==1)
   {
      moveMotorTarget(lm, 35, -10);
      moveMotorTarget(rm, 35, 10);  //reward to clockwise_turn
      waitUntilMotorStop(lm);
      waitUntilMotorStop(rm);
   }
   else
   {
      moveMotorTarget(lm, 35, 10);
      moveMotorTarget(rm, 35, -10);  //reward to counterclockwise_turn
      waitUntilMotorStop(lm);
      waitUntilMotorStop(rm);
   }
   checked_blue=0;
   starttask(check_ball);

   while(SensorValue[left_color]>threshold)
   {
      front_linetracing();
   }
   short_advance();

   kept_x = x;
   kept_y = y;
   if(kept_y==1)
   {
      kept_y=2;
   }
   ignore_letsgo=1;
   if(have_ball==1)
   {
      ignore_letsgo=0;
   }
}
void avoid_ball(int c, int d)
{
   checked_red=0;
   stoptask(count_xy);
   if(on_negative_x==1) // find ball when i was on neg_x
   {
      if(x==2)   //ball is located on 1.
      {
         while(SensorValue[left_color]>threshold)
         {
            backward_advance();
         }
         short_short_advance();
         letsgo(c,d+1);
         ball_x_1=1;
      }
      else if(y==8)
      {
         while(SensorValue[left_color]>threshold)
         {
            backward_advance();
         }
         short_short_advance();
         letsgo(c,d-1);
         letsgo(c-1,d-1);
      }
      else
      {
         while(SensorValue[left_color]>threshold)
         {
            backward_advance();
         }
         short_short_advance();
         letsgo(c,d+1);
         letsgo(c-1,d+1);
      }
   }
   else if(on_positive_x==1)
   {
      if(x==5)
      {
         while(SensorValue[left_color]>threshold)
         {
            backward_advance();
         }
         short_short_advance();
         letsgo(c,d+1);
         ball_x_6=1;
      }
      else if(x==6)
      {
         while(SensorValue[left_color]>threshold)
         {
            backward_advance();
         }
         short_short_advance();
         letsgo(c,d+1);
         ball_x_7=1;   //@1
      }
      else if(y==7)
      {
         while(SensorValue[left_color]>threshold)
         {
            backward_advance();
         }
         short_short_advance();
         letsgo(c,d-1);
         letsgo(c+1,d-1);
      }
      else
      {
         while(SensorValue[left_color]>threshold)
         {
            backward_advance();
         }
         short_short_advance();
         letsgo(c,d+1);
         letsgo(c+1,d+1);
      }
   }
   else if(on_positive_y==1)
   {
      if(x==7)
      {
         while(SensorValue[left_color]>threshold)
         {
            backward_advance();
         }
         short_short_advance();
         letsgo(c-1,d);
         letsgo(c-1,d+1);
         ball_x_7=1;
      }
      else
      {
         while(SensorValue[left_color]>threshold)
         {
            backward_advance();
         }
         short_short_advance();
         letsgo(c+1,d);
         letsgo(c+1,d+1);
         ball_x_1=1;
      }
   }
   else if(on_negative_y==1)
   {
      if(y==2)
      {
         while(SensorValue[left_color]>threshold)
         {
            backward_advance();
         }
         short_short_advance();
         letsgo(c+1,d);
         letsgo(c+1,d-1);
         ball_y_1=1;
      }
      else
      {
         while(SensorValue[left_color]>threshold)
         {
            backward_advance();
         }
         short_short_advance();
         letsgo(c+1,d);
         letsgo(c+1,d-1);
      } 
   }
   starttask(check_ball);
   same_dest=1;
}
void letsgo(int a, int b)
{
   if(ignore_letsgo==0)
   {
      if(y<b) // i want to go up
      {
            look_positive_y(); // look
            startTask(alignment);
            while(y<b)
            {
               front_linetracing(); //go
               if(checked_blue==1)
               {
                  keeping_ball();
                  if(have_ball!=1)
                  {
                     return;
                  }
               }
               if(checked_red==1)
               {
                  avoid_ball(x,y);
                  if(ball_x_7==1||ball_x_1==1)  //@
                  {
                     ball_x_1=0;
                     ball_x_7=0;
                     return;
                  }
               }
            }
            if(y==b && same_dest==0)
            {
               short_advance();
            }
      }
      if(y>b)  // i want to go down
      {
            look_negative_y(); //look
            while(y>b)
            {
               front_linetracing(); //go
               if(checked_blue==1)
               {
                  keeping_ball();
                  if(have_ball!=1)
                  {
                     return;
                  }
               }
               if(checked_red==1)
               {
                  avoid_ball(x,y);
                  if(ball_y_1==1)
                  {
                     return;
                  }
               }
            }
            if(y==b && same_dest==0)
            {
               short_advance();
            }
      }
      if(x<a)  // i already went y, i want to go x(right)
      {
            look_positive_x();
            while(x<a)
            {
               front_linetracing(); //go
               if(checked_blue==1)
               {
                  keeping_ball();
                  if(have_ball!=1)
                  {
                     return;
                  }
               }
               if(checked_red==1)
               {
                  avoid_ball(x,y);
                  if(ball_x_6==1 || ball_x_7==1)
                  {
                     ball_x_7=0;
                     ball_x_6=0;
                     return;
                  }
               }
            }
            if(x==a && same_dest==0)
            {
               short_advance();
            }
      }
      if(x>a)
      {
            look_negative_x();
            while(x>a)
            {
               front_linetracing(); //go
               if(checked_blue==1)
               {
                  keeping_ball();
                  if(have_ball!=1)
                  {
                     return;
                  }
               }
               if(checked_red==1)
               {
                  avoid_ball(x,y);
                  if(ball_x_1==1)
                  {
                     ball_x_1=0;
                     return;
                  }
               }
            }
            if(x==a && same_dest==0)
            {
               short_advance();
            }
      }
      return ;
   }
}
task main()
{
   resetGyro(gyro);
   Starttask(count_xy);
   Starttask(display);
   Starttask(determine_direction);
   Starttask(check_ball);
   srand(nSysTime);
   x=2; y=1;
   while(SensorValue[left_color]<blue_start_threshold)
   {
      front_linetracing();
   }
   short_short_advance();

   for(int i=0; i<10; i++)
   {
      rand_num=abs(rand())%2;

      if(rand_num==0)   //odd_even set
      {   
         //---odd_cycle
         letsgo(7,1);
         letsgo(7,3);
         letsgo(1,3);
         letsgo(1,5);
         letsgo(7,5);
         letsgo(7,7);
         letsgo(0,7);
         letsgo(0,1);
         letsgo(1,1);
         //---------------------------------//
         if(ignore_letsgo==1)
         {
            have_ball=1;
            starttask(check_ball);
            ignore_letsgo=0;
            letsgo(0,kept_y);
            letsgo(0,2);
            letsgo(1,1);
            goal();
            have_ball=0;
         }
         //---even_cycle
         letsgo(2,2);
         letsgo(7,2);
         letsgo(7,4);
         letsgo(1,4);
         letsgo(1,6);
         letsgo(7,6);
         letsgo(7,8);
         letsgo(0,8);
         letsgo(0,1);
         letsgo(1,1);
         if(ignore_letsgo==1)
         {
            have_ball=1;
            starttask(check_ball);
            ignore_letsgo=0;
            letsgo(0,kept_y);
            letsgo(0,2);
            letsgo(1,1);
            goal();
            have_ball=0;
         }
      }
      else         //even_odd set
      {   
         //---even_cycle
         letsgo(2,2);
         letsgo(7,2);
         letsgo(7,4);
         letsgo(1,4);
         letsgo(1,6);
         letsgo(7,6);
         letsgo(7,8);
         letsgo(0,8);
         letsgo(0,1);
         letsgo(1,1);

         if(ignore_letsgo==1)
         {
            have_ball=1;
            starttask(check_ball);
            ignore_letsgo=0;
            letsgo(0,kept_y);
            letsgo(0,2);
            letsgo(1,1);
            goal();
            have_ball=0;
         }
         //---odd_cycle
         letsgo(2,2);
         letsgo(7,1);
         letsgo(7,3);
         letsgo(1,3);
         letsgo(1,5);
         letsgo(7,5);
         letsgo(7,7);
         letsgo(0,7);
         letsgo(0,1);
         letsgo(1,1);
         //---------------------------------//
         if(ignore_letsgo==1)
         {
            have_ball=1;
            starttask(check_ball);
            ignore_letsgo=0;
            letsgo(0,kept_y);
            letsgo(0,2);
            letsgo(1,1);
            goal();
            have_ball=0;
         }
      }
   }
}
